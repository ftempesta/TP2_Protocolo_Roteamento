# -*- coding: utf-8 -*- 
# NÃO SEI USAR SOCKET UDP
# é quase a mesma coisa que tcp, tipo identico.
# sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)#initalising socket and UDP connection
#   Message = str(json_string)
#   print 'Message sent:= ', Message
#   sock.sendto(Message,(UDP_IP, PORT))

#----------------DISCUSSÕES------------------------

# pra que serve esse script lo-addresses.sh???
# ip addr add 127.0.1.1/32 dev lo <--- ele faz isso daqui aparentemente
# ele só cria na sua rede local os endereços que vao ser utilziados pelos roteadores que a gente vai criar
# ex: Roteador A vai ficar no ip 127... /1
#   roteador B vai ficar no ip 127.../ 2
  
# ENTÃO, MAS TIPO, A GENTE QUE PRECISA LIDAR COM ESSE SCRIPT OU ELE VAI CRIAR ESSES IPS? E O NOSSO CÓDIGO JÁ PODE PARTIR DIRETO PARA A PRÓXIMA ETAPA????  
# eu acho que ele cria virtualmente, mas o negocio que a gente tem que atribuir o nosso router.py a cada endereço que ele cria
# NOSSA, COMO QUE FAZ ISSO?
# acho que cada terminal vai ser um ip diferente por causa do script, aí só rodar o programa nesse terminal???nsei
# TÁ, MAS DEPOIS A GENTE PENSA MAIS SOBRE ISSO. POR ENQUANTO PODEMOS ADMITIR QUE OS ENDEREÇOS JÁ ESTÃO CRIADOS E LIDAR COM ISSO. SE FOR O CASO A GENTE MUDA DEPOIS
# ok
  
  
# pelo que entendi primeiro temos que adicionar os endereços à uma determinada interface loopback. Que, pelo que entendi seria adicionar os endereços que vamos usar
# E depois fazer o link entre eles determinando o custo (ou serja, a tabela). FAZ SENTIDO ISSO?


# AQUI, ANTES DA GENTE COMEÇAR A ESCREVER CÓDIGO, VAMOS ESCREVER EM PORTUGUÊS TUDO QUE O ALGORITMO PRECISA TER E EM QUE ORDEM E SÓ DEPOIS A GENTE PASSA PRA PYTHON?
# ok

# VAI FICAR MAIS FÁCIL MODELAR TODO O PROBLEMA SEM SE PERDER E NEM ESQUER DE NENHUM DETALHE

# EU JÁ COMECEI AQUI EM BAIXO. VAI DANDO UMA OLHADA


#------------------FIM DISCUSSÕES-----------------


#--------------------INICIO----------------------
import sys
import socket
import json
import time

#-----------comando add <ip> <weight>----------------
def adicionaRoteador(vizinhos, comando, roteadores):
    ip = comando[1]
    peso = comando[2]
  
  #Um add pode ser de um roteador já existente, a gente tem que verificar pra mudar o peso dele
  #for i in range(len(roteadores)):
  #  if(roteadores[i][0] == ip)
  
  #se nao for um roteador existente na lista
    roteadores.append([ip, peso])

  
#--------------comando del <ip>--------------------
def deletaRoteador(vizinhos, comando):
    ip = comando[1]
#     for i in range(len(vizinhos)):
#         if(vizinhos[i][0] == ip)
#             vizinhos.delete(vizinhos[i])



#---------------mensagem de dados-------------------
#payload = mensagem trace
def criaMensagemData(ipDestino, ipOrigem, payload):
    print(json.dumps({'type': 'data', 'source': ipOrigem, 'destination': ipDestino, 'payload': payload}, indent=2))

#--------------comando trace <ip>------------------
def ratreaRoteador(vizinhos, comando, ipOrigem):
    ipDestino = comando[1]
    hops = [ipOrigem]
    
    #cria JSON de trace
    msgTrace = json.dumps({'type': 'trace', 'source': ipOrigem, 'destination': ipDestino, 'hops': hops}, indent=2)
    print(msgTrace)
    #cria payload para usar em msgData
    payload = json.dumps({'type': 'trace', 'source': ipOrigem, 'destination': ipDestino, 'hops': hops})
    criaMensagemData(ipDestino, ipOrigem, payload)


a saida é essa aqui 
trace 127.0.1.2
{
  "type": "trace",
  "source": "127.0.1.1",
  "destination": "127.0.1.2",
  "hops": [
    "127.0.1.1"
  ]
}
{
  "type": "data",
  "source": "127.0.1.1",
  "destination": "127.0.1.2",
  "payload": "{\"type\": \"trace\", \"source\": \"127.0.1.1\", \"destination\": \"127.0.1.2\", \"hops\": [\"127.0.1.1\"]}"
}



então vamos pensar no trace
se eu receber o comando trace 127.0.1.2 significa que eu quero fazer uma conexão com o 2.
 Então o que é a primeira coisa que temos que fAZER? 
 vamos supor que a gente é o 1. então temos que ver se o 2 é um dos vizinhos do 1 certo
 e depois?
 se for
se for a gente cria o json com ele que nem vc fez ali em cima    
ok, mas se não for, como faremos para descobrir como chegar no 2?
ah entao, acho que aí entrariam os vizinhos
pq a gente teria os pesos dos caminhos antes mesmo de começar a mandar as coisas
mas nao sei como fazer, só achei q fosse uma boa
eu até estou te entendendo, mas tem alguns detalhes que ainda não fazerm sentido pra mim
como que vamos saber os vizinhos dos nosso vizinhos se ele estão em tese rodando em outro terminal?
ah, quando a gente manda o trace a gente pode optar por mandar sempre pro roteador com menor caminhos
se o 1 tem caminho pro 2 com peso 5 e caminho pro 3 com caminho 10, a gente pode ir pro caminho 2 primeiro pra veraté retornar
até aí tudo bem, mas o ponto é como que eu já descobri que ah ta Vai ter que tipo ou mandar pros dois e depois ver ate onde isso leva
 e meio que aprende o caminho, não sei
pode ser, vai funcionar como broadcast
pelo que o Futini tinha me falado ontem seria assim
Eu só ainda não estou sacando como a gente faz pra mandar msg pra todo mundo, mas vamos indo que a gente parende
manda pra toda a lista de roteadores q a gente tem pelo add, forzão. ok eu só não sei o comando send pra udṕ, mas só procirar
mesma coisa, acho que é só send
o inicio q é diferente

então se o comando for trace, monta o json e manda pra todos os vizinho. certo? será que a gente deveria trocar o nome da lista de roteadores para 
vizinhos?
acho que nao PRECISA
só nao to certo desse negocio de broadcast
vou ver aqui

Eu acho que faz sentido sim, porque quando sua msg chegar ao destino final, ele vai te responder com uma msg data e lá vai conter em
 payload o json
trace, ou seja, o caminho que foi aprendido para chegar até o destino

se bem que estou na duvida agora. Acabei de ler que se o roteador NÃO for o destino, ele encaminha 
a msg atraves dos caminhos mais curtos e add seu endereço no campo hops
o que em tese era para fazer com que, no inicio, ele encaminhasse só para os vizinhos com caminho mais curtos
entao, aí nao é broadcast
pois é, eu to na duvida sobr ISSO
queria saber se: e se nao chegasse, uai, aí acho que se der um tempo e ninguem responder ele vai entender que não existe mais 
esse roteador
nao sei um exemplo agora
mas tipo
e se ele pegar o caminho menor e no final esse caminho nao era o mlehor
e era melhor ter pego um mais caro aqui pq o resto todo ia ser barato
pois é. Eu tambem tenho essa duvida
mas e tao complicado perguntar pro povo que ta fazendo a materia, pq pode ser que eles 
entenderam errado e estão achando que estão fazendo certo





faz esse exemplo aqui ó:
    A1, A2, A3
  /           \
A              C

  \          /
    B1,B2,B3

, mas aqui tem quer ser algo maior que 1, não? nao pq pra ir pro b1 é 50 ah é . 
olhei a linha de baixo e vc quer ir de onde para onde?
A pro C

rota = A - A1 - A2 - A3 - C = 1 + 50 + 30 + 100 = 181
     = A - B1 - B1 - B3 - C = 50 +1 + 2 + 1 = 54

     só tem essas duas opções de rota, mas tipo, acho que não necessariamente a rota que vc vai pegar é a menor de todas. é?
    o trace garante que seja a menor rota possivel entre os roteadores
    uai, então não sei como modelar isso. Pq meio que vc tem que fazer o caminho todo para poder descobrir qual é a menor
    entao, se a gente tivesse já ao adcionar os roteadores os pesos e os caminhos menores já dava pra saber
    tem que pensar como faz isso
    nossa, eu confesso que não estou tendo ideia NÃO
    kkkkkkkkkkk
    sim
    to olhando uns video aqui no youtube, uns links pra ver se tem alguma ideia
    e depois que a gente matar essa charada, acho que vai ficar bem mais facil tudo. Vai ser implementar, ne 

    Eu achei um video que ajudou um pouco, mas estou com muito sono, 
    então por mais que eu tenha entendido não vou conseguir implementar agora não

    tudo bem, vou ver se eu escrevo algo ainda hj
    mas vamo ter q perguntar como q vai funcionar isso
    qualquer coisa deixa as duvidas anotadas que eu vou pra ufmg depois do almoço e já procuro os monitores

    copia o código aí pq eu não sei se vai ficar atualizado pra vc quando eu sair
    commita ele
    sem os comentarios

A pra A1: peso 1
A1 pra A2: peso 50
A2 pra A3: peso 30
A3 pra C: peso 100

A pra b1: peso 50
B1 pra B2: peso 1
B2 pra B3: peso 2
B3 pra C: peso 1




#/router.py <ADDR> <PERIOD> [STARTUP]
# <PERIOD>: tempo para fazer o update

port = 55151
addr = sys.argv[1]
period = sys.argv[2]
# ESSE CAMPO É OPCIONAL
startup = sys.argv[3]

#Listas
roteadores = []
vizinhos = []

#isso daqui vai bindar o roteador com o IP referente a ele,  criado pelo script lá
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
sock.bind((addr, port))


while True:
    comando = input()
    comando = comando.split(' ')

    if (comando[0] == "add"):
        adicionaRoteador(vizinhos, comando, roteadores)
        print("add")
        continue
    
    if (comando[0] == "del"):
        deletaRoteador(vizinhos, comando)
        print("del")
        continue
  
    if(comando[0] == "trace"):
        #criar funcao pra calcular trace
        ratreaRoteador(vizinhos, comando, addr)
        print("trace")
        continue
    
    #só termina com Ctrl + c 
    else: 
        sys.exit() 
    
    
  #deve mandar um update toda hora, nao sei se eu entendi
  #A CADA PI(constante durante a execução do roteador - PERIOD) SEGUNDOS ELE DEVE MANDAR MSG DE UPDATE. 
  #ai depois tem que ter um delay e volta a receber comandos
    # time.sleep(period)#delay







# -------------------- PRIMEIRA COISA DE CODIGO A SE FAZER: criar a tabela ADD para todos os roteadores, com o nome de destino e o peso--------------------

#   CRIAR TOPOLOGIA
#   1. ADICIONAR ENLACE
#           ---add <ip> <peso>---
#           ---exemplo: para o endereço 127.0.1.5:---
#           ---add 127.0.1.1 10---
#           ***adicionar um enlace entre o roteador corrente e o roteador passado por parametro***

#           Para cada um dos endereços
#           Enquanto ainda tiver endereços para serem lidos
#                   Le endereço pelo comando add, endereço e peso
#                   cria uma tabela de roteamento para esse endereço


# -------------------nao sei aonde que a gente vai usar isso, vou ver n os exemplos ---------------------------------
#   2. DELETAR ENLACE
#           ***Comando DEL <ip>: remove o enlace entre o roteador corrente e o roteador passado por parametro***
#       

#---------------------Depois de todo mundo já ter a tabela, criar um JSON object, ou seja, uma struct com os seguintes campos:
#source—Especifica o endereço IP do programa que originou a mensagem.
#destination—Especifica o endereço IP do programa destinatário da mensagem.
#type—Especifica o tipo da mensagem, sua semântica, e quaisquer campos adicionais. Nestetrabalho implementaremos três tipos de mensagem:data(seção 3.1),update(seção 4.1)etrace(seção 5)
# EX DE COMO DEVE FICAR::
#{
#  "type": "data",
#  "source": "127.0.1.2",
#  "destination: "127.0.1.1",
#} 


#---------------------- DEPOIS DE CRIAR O OBJECT JSON, TEMOS QUE PREOCUPAR EM FAZER OS 3 TIPOS DE MENSAGENS---------------------------------------------




#--------------------Mensagem: DATA -------------------------------
#com um campo "payload" a mais no OBJECT, com uma mensagem qualquer que vai ser transmitida do source para o destination

#--------------------Mensagem: UPDATE --------------------------------------
#esse daqui manda um "distances" e vai atualizar o peso, mas aparentemente a gente tem que cuidar de "Atualizações periodicas" e "Split Horizon"

#--------------------Mensagem: TRACE --------------------------------------
#medir a rota utilizada entre dois roteadores 
#campos:
#           type
#           source
#           destination
#           "hops": armazena lista de roteadores por onde a msg de trace já passou

#quando receber essa mensagem de trace, roteador deve add seu ip ao final da lista no campo "hop" da mensagem. 
#se roteador FOR o destino do trace
#       enviar msg "data" para roteador que originou o "trace" - "payload" = string com json correspondente à msg de trace 
#senão
#       encaminhar a msg por um dos caminhos mair curtos que conhece até o destino
#       **MSG DE TRACE ESTÃO SUJEITAS A BALANCEAMENTO DE CARGA (DIVIDIR CARGA EM CASO DE EMPATE DE CAMINHO MAIS CURTO)
#
# --trace <ip>: roteador cria uma msg de rastreamento para o roteador com endereço <ip>

#******CALCULAR A ROTA MAIS CURTA*********
# o roteador deve armazenar informações sobre TODAS as rotas conhecidas em uma tabela de roteamento. 
# calcular rota mais curta - algoritmo de Dijkstra
# Emcaminhar dados através da rota mais curta   






